package algorithms

import (
	"reflect"
	"testing"
)

func TestFactorial(t *testing.T) {

	type testpair struct {
		value  int
		result int
	}

	var tests = []testpair{
		{1, 1},
		{2, 2},
		{3, 6},
		{10, 3628800},
		{20, 2432902008176640000},
	}

	for _, pair := range tests {
		v := Factorial(pair.value)
		if v != pair.result {
			t.Error(
				"For", pair.value,
				"expected", pair.result,
				"got", v,
			)
		}
	}
}

func TestFactorialTail(t *testing.T) {

	type testpair struct {
		value  int
		result int
	}

	var tests = []testpair{
		{1, 1},
		{2, 2},
		{3, 6},
		{10, 3628800},
		{20, 2432902008176640000},
	}

	for _, pair := range tests {
		v := FactorialTail(pair.value)
		if v != pair.result {
			t.Error(
				"For", pair.value,
				"expected", pair.result,
				"got", v,
			)
		}
	}
}

func BenchmarkFactorial(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Factorial(150)
	}
}

func BenchmarkFactorialTail(b *testing.B) {
	for i := 0; i < b.N; i++ {
		FactorialTail(150)
	}
}

func TestTowersOfHanoi(t *testing.T) {

	type testpair struct {
		num    int
		result string
	}

	var tests = []testpair{
		{1, "1AC"},
		{2, "1AB2AC1BC"},
		{3, "1AC2AB1CB3AC1BA2BC1AC"},
		{4, "1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC"},
		{10, "1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC5AB1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB6AC1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA5BC1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC7AB1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB5CA1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA6CB1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC5AB1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB8AC1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA5BC1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC6BA1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB5CA1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA7BC1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC5AB1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB6AC1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA5BC1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC9AB1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB5CA1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA6CB1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC5AB1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB7CA1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA5BC1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC6BA1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB5CA1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA8CB1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC5AB1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB6AC1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA5BC1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC7AB1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB5CA1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA6CB1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC5AB1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB10AC1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA5BC1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC6BA1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB5CA1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA7BC1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC5AB1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB6AC1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA5BC1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC8BA1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB5CA1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA6CB1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC5AB1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB7CA1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA5BC1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC6BA1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB5CA1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA9BC1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC5AB1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB6AC1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA5BC1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC7AB1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB5CA1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA6CB1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC5AB1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB8AC1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA5BC1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC6BA1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB5CA1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA7BC1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC5AB1CA2CB1AB3CA1BC2BA1CA4CB1AB2AC1BC3AB1CA2CB1AB6AC1BC2BA1CA3BC1AB2AC1BC4BA1CA2CB1AB3CA1BC2BA1CA5BC1AB2AC1BC3AB1CA2CB1AB4AC1BC2BA1CA3BC1AB2AC1BC"},
	}

	for _, pair := range tests {
		v := TowersOfHanoi(pair.num)
		if v != pair.result {
			t.Error(
				"For", pair.num,
				"expected", pair.result,
				"got", v,
			)
		}
	}
}

func TestGCD(t *testing.T) {

	type testpair struct {
		values []int
		result int
	}

	var tests = []testpair{
		{[]int{1, 2}, 1},
		{[]int{3, 2}, 1},
		{[]int{6, 2}, 2},
		{[]int{4534532, 576452}, 4},
		{[]int{97406784, 123456}, 123456},
	}

	for _, pair := range tests {
		v := GCD(pair.values[0], pair.values[1])
		if v != pair.result {
			t.Error(
				"For", pair.values[0], "and", pair.values[1],
				"expected", pair.result,
				"got", v,
			)
		}
	}
}

func TestFibonacci(t *testing.T) {

	type testpair struct {
		value  int
		result int
	}

	var tests = []testpair{
		{0, 0},
		{1, 1},
		{2, 1},
		{3, 2},
		{10, 55},
		{12, 144},
		{20, 6765},
		{30, 832040},
	}

	for _, pair := range tests {
		v := Fibonacci(pair.value)
		if v != pair.result {
			t.Error(
				"For", pair.value,
				"expected", pair.result,
				"got", v,
			)
		}
	}
}
func TestPermutation(t *testing.T) {

	type testpair struct {
		data   []int
		i      int
		length int
		result [][]int
	}

	var tests = []testpair{
		// {[]int{1, 2}, 0, 2, []int{1, 2}},
		// {[]int{1, 2, 3}, 0, 3, [][]int{{1, 2, 13}, {1, 2, 13}}},
		// {[]int{1, 2, 3, 4, 5}, 0, 3, []int{1, 1}},
		// {[]int{1, 2, 3, 4, 5}, 1, 3, []int{1, 1}},
		// {[]int{0, 1, 2, 3, 4}, 0, 5, []int{1, 1}},
	}

	for _, pair := range tests {
		v := Permutation(pair.data, pair.i, pair.length)
		if !reflect.DeepEqual(v, pair.result) {
			t.Error(
				"For", pair.data,
				"expected", pair.result,
				"got", v,
			)
		}
	}
}
func TestBinarySearchRecursive(t *testing.T) {

	type testelements struct {
		values []int
		low    int
		high   int
		item   int
		result int
	}

	var tests = []testelements{
		// {[]int{1, 2}, 0, 1, 3, -1},
		// {[]int{-6, 1, 1, 1, 1, 1, 1}, 0, 6, 3, -1},
		{[]int{-6, 1, 1, 1, 1, 1, 1}, 0, 6, -6, 0},
		{[]int{-6, 1, 1, 1, 1, 1, 1}, 0, 6, 1, 3}, //  the result may be inaccurate due to several identical values satisfying the condition
		{[]int{1, 2, 3, 4, 5, 6, 7}, 0, 6, 3, 2},
		{[]int{1, 2, 3, 4, 5, 6, 7}, 0, 6, 5, 4},
		{[]int{1, 2, 3, 4, 5, 6, 7, 8}, 0, 7, 8, 7},
		{[]int{-1, 1}, 0, 1, 3, -1},
		{[]int{-1, 1}, 0, 1, -1, 0},
		{[]int{0, 0}, 0, 1, 3, -1},
		{[]int{-400, -321, 1, 110, 145, 234, 300, 780}, 0, 7, 3, -1},
		{[]int{-400, -321, 1, 110, 145, 234, 300, 780}, 0, 7, 110, 3},
		{[]int{-400, -321, 1, 110, 145, 234, 300, 780}, 0, 7, 300, 6},
		{[]int{-400, -321, 1, 110, 145, 234, 300, 780}, 0, 7, 780, 7},
		{[]int{-400, -321, 1, 110, 145, 234, 300, 780}, 0, 7, -321, 1},
	}

	for _, element := range tests {
		v := BinarySearchRecursive(element.values, element.low, element.high, element.item)
		if v != element.result {
			t.Error(
				"For", element.values,
				"expected", element.result,
				"got", v,
			)
		}
	}
}
